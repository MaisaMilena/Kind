// sleep: Can't attack on the next turn
// burn: Loses 1/16 mhp for X turns
// protect: Takes 50% less damage on the next turn
// minimize: Takes 25% less damage for each of the next turns
// invulnerable: can't be attacked by effects of physical damage
// hit: a damage to be applied in the next turn
// poison: a damage executed every turn until the battle ends
type Mons.Effect {
  new(
    sleep: Pair(U32, Bool),
    burn: U32, // turns that will last
    protect: Pair(U32, Bool), // fst: if 1u, will be applied on the same turn
    minimize: Pair(U32, Bool),
    invulnerable: Pair(Bool, Bool), // fst: if is invulnerable, snd: if used it last turn
    hit: U32,
    poison: Bool,
    swap_agi: Bool)
}

Mons.Effect.clear: Mons.Effect
  let clean = {0u, Bool.false}
  let clean_bool = {Bool.false, Bool.false}
  Mons.Effect.new(clean, 0u, clean, clean, clean_bool, 0u, 
    Bool.false, Bool.false)

Mons.Effect.upd_initial_eff(eff: Mons.Effect): Mons.Effect
  open eff
  Mons.Effect.new(
    eff.sleep, 
    U32.sub(eff.burn, 1u), 
    eff.protect, 
    eff.minimize, 
    eff.invulnerable, 
    0u, // hit only last for the next turn
    eff.poison,
    Bool.false) 

Mons.Effect.upd_end_turn_eff(eff: Mons.Effect): Mons.Effect
  open eff
  let sleep_turn = Pair.fst<_,_>(eff.sleep)
  let protect_turn = Pair.fst<_,_>(eff.protect)
  let minimize_turn = Pair.fst<_,_>(eff.minimize)
  let invulnerable = Pair.fst<_,_>(eff.invulnerable)
  let update_turn_counter = ((val) {U32.sub(val, 1u), U32.eql(val, 2u)}) :: U32 -> Pair(U32, Bool)
  Mons.Effect.new(
    update_turn_counter(sleep_turn),
    eff.burn, 
    update_turn_counter(protect_turn),
    update_turn_counter(minimize_turn), 
    if invulnerable then {Bool.false, Bool.true} else {Bool.false, Bool.false}, 
    eff.hit,
    eff.poison,
    eff.swap_agi)

Mons.Effect.has_sleep(eff: Mons.Effect): Bool
  open eff 
  let turn = Pair.fst<_,_>(eff.sleep)
  U32.eql(turn, 1u)

Mons.Effect.has_burn(eff: Mons.Effect): Bool
  open eff 
  U32.gtn(eff.burn, 0u)

// His only last 1 turn, so if it has a values, is the value of the dmg
Mons.Effect.has_hit(eff: Mons.Effect): Bool
  open eff
  U32.gtn(eff.hit, 0u)

Mons.Effect.has_minimize(eff: Mons.Effect): Bool
  open eff 
  let {turn, used} = eff.minimize
  U32.gtn(turn, 0u)

// 0u: don't have
// 1u: it has protect for the current turn
// 2u: available next turn
Mons.Effect.has_protect(eff: Mons.Effect): Bool
  open eff 
  let turn = Pair.fst<_,_>(eff.protect)
  U32.eql(turn, 1u)

Mons.Effect.has_invulnerable(eff: Mons.Effect): Bool
  open eff 
  let {stt, used} = eff.invulnerable
  stt

Mons.Effect.has_poison(eff: Mons.Effect): Bool
  open eff
  eff.poison

Mons.Effect.has_swap_agi(eff: Mons.Effect): Bool
  open eff 
  eff.swap_agi

Mons.Effect.set_sleep(obj: Mons.Object, turn: U32): Mons.Object
  open obj
  open obj.eff as eff
  let new_eff = Mons.Effect.new({turn, Bool.true}, eff.burn, eff.protect, eff.minimize, 
    eff.invulnerable, eff.hit, eff.poison, eff.swap_agi)
  Mons.Object.set_eff(new_eff, obj)

Mons.Effect.set_invulnerable(obj: Mons.Object): Mons.Object
  open obj
  open obj.eff as eff
  let {stt, used} = eff.invulnerable
  let new_eff = Mons.Effect.new(eff.sleep, eff.burn, eff.protect, eff.minimize, 
    {Bool.true, Bool.true}, eff.hit, eff.poison, eff.swap_agi)
  Mons.Object.set_eff(new_eff, obj)

Mons.Effect.set_burn(obj: Mons.Object, turns: U32): Mons.Object
  open obj
  open obj.eff as eff
  let new_eff = Mons.Effect.new(eff.sleep, turns, eff.protect, eff.minimize, 
    eff.invulnerable, eff.hit, eff.poison, eff.swap_agi)
  Mons.Object.set_eff(new_eff, obj)

// Hit to be executed next turn
Mons.Effect.set_hit(obj: Mons.Object, val: U32): Mons.Object
  open obj
  open obj.eff as eff
  let new_eff = Mons.Effect.new(eff.sleep, eff.burn, eff.protect, eff.minimize, 
    eff.invulnerable, val, eff.poison, eff.swap_agi)
  Mons.Object.set_eff(new_eff, obj)

Mons.Effect.set_protect(obj: Mons.Object, turn: U32): Mons.Object
  open obj
  open obj.eff as eff
  let new_eff = Mons.Effect.new(eff.sleep, eff.burn, {turn, Bool.true}, eff.minimize, 
    eff.invulnerable, eff.hit, eff.poison, eff.swap_agi)
  Mons.Object.set_eff(new_eff, obj)

Mons.Effect.set_poison(obj: Mons.Object): Mons.Object
  open obj
  open obj.eff as eff
  let new_eff = Mons.Effect.new(eff.sleep, eff.burn, eff.protect, eff.minimize, 
    eff.invulnerable, eff.hit, Bool.true, eff.swap_agi)
  Mons.Object.set_eff(new_eff, obj)

Mons.Effect.set_minimize(obj: Mons.Object): Mons.Object
  open obj
  open obj.eff as eff
  let new_eff = Mons.Effect.new(eff.sleep, eff.burn, eff.protect, {2u, Bool.true}, 
    eff.invulnerable, eff.hit, eff.poison, eff.swap_agi)
  Mons.Object.set_eff(new_eff, obj)

Mons.Effect.set_swap_agi(obj: Mons.Object): Mons.Object
  open obj
  open obj.eff as eff
  let new_eff = Mons.Effect.new(eff.sleep, eff.burn, eff.protect, eff.minimize, 
    eff.invulnerable, eff.hit, eff.poison, Bool.true)
  Mons.Object.set_eff(new_eff, obj)

